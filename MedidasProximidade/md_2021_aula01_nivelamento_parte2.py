# -*- coding: utf-8 -*-
"""MD-2021-Aula01-Nivelamento-Parte2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11NIB9S8cnSiuICQPKlLON9URHKGeava5

# <font color="red">Mineração de Dados Não Estruturados</font>
## <span style="color:red">Aula 01 - Nivelamento (Conceitos Básicos) - Parte 2</span>

#### Material de Apoio - Prática sobre Medidas de Proximidade

# Importando bibliotecas
"""

import numpy as np
import pandas as pd
from sklearn.neighbors import NearestNeighbors
from sklearn import preprocessing

"""# Medidas de Proximidade

Para realizarmos experimentos com medidas de proximidade, usaremos uma amostra de uma base de dados sobre campanhas de marketing direto de uma instituição bancária portuguesa. As campanhas de marketing foram baseadas em ligações telefônicas. Mais informações sobre o conjunto de dados estão disponíveis em Moro et al. (2014).

[1] [Moro et al., 2014] S. Moro, P. Cortez and P. Rita. A Data-Driven Approach to Predict the Success of Bank Telemarketing. Decision Support Systems, Elsevier, 62:22-31, June 2014

# Leitura dos dados *bank_marketing.csv*

Usamos o pandas para leitura do arquivo CSV.
Em seguida, as 30 primeiras linhas são exibidas.
Os dados já estão pré-processados.

Cada linha representa um cliente do banco. Cada coluna representa um atributo do cliente.

Atributos:

* **age**: Idade do cliente
* **balance**: saldo em conta do cliente
* **duration**: duração (em segundos) do último contato do banco com o cliente
"""

dados = pd.read_csv('bank.csv')
dados

dados.head(30)

"""# Uma breve análise dos atributos"""

dados.age.hist()

dados.balance.hist()

dados.duration.hist()

"""# Testando medidas de proximidade
Medidas: Euclidiana, Manhattan, Suprema (chebyshev)

Usaremos o método NearestNeighbors do Scikit-Learn para testar nossas medidas de proximidade.

**metric** = define a medida de proximidade desejada

**n_neighbors** = determina quantos vizinhos mais próximos iremos localizar considerando a medida selecionada.
"""

nbrs = NearestNeighbors(metric='euclidean',n_neighbors=7).fit(dados)

"""Vamos localizar 7 objetos mais próximos de acordo com atributos definidos manualmente."""

age = 30
balance = 200
duration = 30

distances, indices = nbrs.kneighbors([[age,balance,duration]])

"""A variável *indices* armazena os IDs (pandas) dos objetos mais próximos encontrados.

A variável *distances* armazena os valores das distâncias.
"""

indices[0]

distances

"""Vamos usar essas variáveis para filtrar os objetos mais próximos em um dataframe do pandas."""

resultado = dados.iloc[indices[0]]
resultado

"""Vamos adicionar os valores de distância nos nossos resultados."""

resultado['distance'] = distances[0]

resultado

"""Agora, vamos repetir esse procedimento para outras medidas de proximidade e comparar os resultados."""

nbrs = NearestNeighbors(metric='manhattan',n_neighbors=7).fit(dados)

age = 30
balance = 200
duration = 30

distances, indices = nbrs.kneighbors([[age,balance,duration]])
resultado = dados.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

nbrs = NearestNeighbors(metric='chebyshev',n_neighbors=7).fit(dados)

age = 30
balance = 200
duration = 30

distances, indices = nbrs.kneighbors([[age,balance,duration]])
resultado = dados.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

nbrs = NearestNeighbors(metric='minkowski',n_neighbors=7, p=2).fit(dados)

age = 30
balance = 200
duration = 30

distances, indices = nbrs.kneighbors([[age,balance,duration]])
resultado = dados.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

"""# Testando o efeito da normalização dos dados na medida de proximidade"""

dados.var()

nbrs = NearestNeighbors(metric='euclidean',n_neighbors=7).fit(dados)

objeto_id = 5
print(dados.loc[objeto_id],"\n")
age = dados.loc[objeto_id].age
balance = dados.loc[objeto_id].balance
duration = dados.loc[objeto_id].duration

distances, indices = nbrs.kneighbors([[age,balance,duration]])
resultado = dados.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

min_max_scaler = preprocessing.MinMaxScaler() # normalização min-max
dados_norm = pd.DataFrame(min_max_scaler.fit_transform(dados))
dados_norm.columns = dados.columns
dados_norm

dados_norm.var()

dados_norm

nbrs = NearestNeighbors(metric='euclidean',n_neighbors=7).fit(dados_norm)

objeto_id = 5
print(dados_norm.loc[objeto_id],"\n")
age = dados_norm.loc[objeto_id].age
balance = dados_norm.loc[objeto_id].balance
duration = dados_norm.loc[objeto_id].duration

distances, indices = nbrs.kneighbors([[age,balance,duration]])
resultado = dados_norm.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

nbrs = NearestNeighbors(metric='manhattan',n_neighbors=7).fit(dados_norm)

objeto_id = 5
print(dados_norm.loc[objeto_id],"\n")
age = dados_norm.loc[objeto_id].age
balance = dados_norm.loc[objeto_id].balance
duration = dados_norm.loc[objeto_id].duration

distances, indices = nbrs.kneighbors([[age,balance,duration]])
resultado = dados_norm.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

"""# Leitura dos dados *bank_marketing_binary.csv*

Usamos o pandas para leitura do arquivo CSV.
Em seguida, as 30 primeiras linhas são exibidas.
Os dados já estão pré-processados.

Cada linha representa um cliente do banco. Cada coluna representa um **atributo binário** do cliente.
"""

dados = pd.read_csv('bank_marketing_binary.csv')
dados.head(30)

nbrs = NearestNeighbors(metric='jaccard',n_neighbors=70).fit(dados)

marital_divorced=1
marital_married=0
marital_single=0

education_primary=0
education_secondary=0
education_tertiary=1

contact_cellular=1
loan=0
housing=1

distances, indices = nbrs.kneighbors([[marital_divorced,
                                       marital_married,
                                       marital_single,
                                       education_primary,
                                       education_secondary,
                                       education_tertiary,
                                       contact_cellular,
                                       loan,
                                       housing]])
resultado = dados.iloc[indices[0]]
resultado['distance'] = distances[0]

resultado

"""# Informações complementares

* Outra medidas de distâncias no Scikit-Learn:

https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.DistanceMetric.html#sklearn.neighbors.DistanceMetric

"""