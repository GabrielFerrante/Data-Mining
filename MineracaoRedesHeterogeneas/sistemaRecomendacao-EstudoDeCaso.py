# -*- coding: utf-8 -*-
"""
Created on Fri Nov 26 02:59:53 2021

@author: gabriel
"""

# -*- coding: utf-8 -*-
"""Mineração em Redes Heterogêneas - Estudo de Caso - Sistemas de Recomendação.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wsTgOqkJXDjwZ_tzVGJrD2jREg053XRA

# Estudo de caso
* Paper: SHI, Chuan et al. Heterogeneous information network embedding for recommendation. IEEE Transactions on Knowledge and Data Engineering, v. 31, n. 2, p. 357-370, 2018.

# Instalando bibliotecas e obtendo o dataset
"""

!git clone https://github.com/phanein/deepwalk
!cd deepwalk; pip install -r requirements.txt
!cd deepwalk; python setup.py install

!git clone https://github.com/librahu/HERec
!mv HERec/* .

!cp -afxr data data_backup

"""# Obtendo uma amostra dos dados
* Reduzimos o dataset apenas por uma questão de tempo (para executar o exemplo durante a aula)

## Relação Usuário x Itens
"""

import pandas as pd

MAX_USERS = 4000
MAX_ITEMS = 3000

df_data = pd.read_csv('data_backup/ub.txt',sep="\t",header=None)


df_data = df_data[df_data[0] <= MAX_USERS]
df_data = df_data[df_data[1] <= MAX_ITEMS]
df_data

"""## Distribuição dos dados em relação aos ratings"""

df_data[2].hist(bins=5)

"""## Divisão em treino e teste (80% para treino e 20% para teste)"""

from sklearn.model_selection import train_test_split

df_data = df_data.sample(frac=1)

df_data_train, df_data_test = train_test_split(df_data, test_size=0.2, random_state=42)

print('Train: ', df_data_train.shape[0])
print('Test: ', df_data_test.shape[0])

df_data_train.to_csv('data/ub_0.8.train',sep="\t",header=None,index=False)
df_data_test.to_csv('data/ub_0.8.test',sep="\t",header=None,index=False)

"""## Relação Item (Business) x Categoria"""

df_data = pd.read_csv('data_backup/bca.txt',sep="\t",header=None)
df_data = df_data[df_data[0] <= MAX_ITEMS]
df_data.to_csv('data/bca.txt',sep="\t",header=None,index=False)
df_data

df_data[1].hist()

"""## Relação Item (Business) x Cidade"""

df_data = pd.read_csv('data_backup/bci.txt',sep="\t",header=None)
df_data = df_data[df_data[0] <= MAX_ITEMS]
df_data.to_csv('data/bci.txt',sep="\t",header=None,index=False)
df_data

df_data[1].hist()

"""## Relação Usuário x Elogio (Compliment)"""

df_data = pd.read_csv('data_backup/uco.txt',sep="\t",header=None)
df_data = df_data[df_data[0] <= MAX_USERS]
df_data.to_csv('data/uco.txt',sep="\t",header=None,index=False)
df_data

df_data[1].hist()

"""## Relação Usuário x Usuário"""

df_data = pd.read_csv('data_backup/uu.txt',sep="\t",header=None)
df_data = df_data[df_data[0] <= MAX_USERS]
df_data = df_data[df_data[1] <= MAX_USERS]
df_data.to_csv('data/uu.txt',sep="\t",header=None,index=False)
df_data

"""# Gerando os Metapaths da HIN (Heterogeneous Information Network)"""

import numpy as np

class metapathGeneration:
    def __init__(self, unum, bnum, conum, canum, cinum):
        self.unum = unum + 1
        self.bnum = bnum + 1
        self.conum = conum + 1
        self.canum = canum + 1
        self.cinum = cinum + 1
        ub = self.load_ub('data/ub_0.8.train')
        self.get_UBU(ub, 'data/metapath/ubu_0.8.txt')
        self.get_UBCaBU(ub, 'data/bca.txt', 'data/metapath/ubcabu_0.8.txt')
        self.get_UBCiBU(ub, 'data/bci.txt', 'data/metapath/ubcibu_0.8.txt')
        self.get_BUB(ub, 'data/metapath/bub_0.8.txt')
        self.get_BCiB('data/bci.txt', 'data/metapath/bcib_0.8.txt')
        self.get_BCaB('data/bca.txt', 'data/metapath/bcab_0.8.txt')

    def load_ub(self, ubfile):
        ub = np.zeros((self.unum, self.bnum))
        with open(ubfile, 'r') as infile:
            for line in infile.readlines():
                user, item, rating = line.strip().split('\t')
                ub[int(user)][int(item)] = 1 
        return ub
    
    def get_UCoU(self, ucofile, targetfile):
        print ('UCoU...')
        uco = np.zeros((self.unum, self.conum))
        with open(ucofile, 'r') as infile:
            for line in infile.readlines():
                u, co, _ = line.strip().split('\t')
                uco[int(u)][int(co)] = 1

        uu = uco.dot(uco.T)
        print (uu.shape)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(uu.shape[0]):
                for j in range(uu.shape[1]):
                    if uu[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(uu[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
    
    def get_UU(self, uufile, targetfile):
        print ('UU...')
        uu = np.zeros((self.unum, self.unum))
        with open(uufile, 'r') as infile:
            for line in infile.readlines():
                u1, u2, _ = line.strip().split('\t')
                uu[int(u1)][int(u2)] = 1
        r_uu = uu.dot(uu.T)

        print (r_uu.shape)
        print ('writing to file...')
        total = 0 
        with open(targetfile, 'w') as outfile:
            for i in range(r_uu.shape[0]):
                for j in range(r_uu.shape[1]):
                    if r_uu[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(r_uu[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
                                                                                                                                     

    def get_UBU(self, ub, targetfile):
        print ('UMU...')
        print(ub.shape)
        uu = ub.dot(ub.T)
        print (uu.shape)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(uu.shape[0]):
                for j in range(uu.shape[1]):
                    if uu[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(uu[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
    
    def get_BUB(self, ub, targetfile):
        print ('MUM...')
        mm = ub.T.dot(ub)
        print (mm.shape)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(mm.shape[0]):
                for j in range(mm.shape[1]):
                    if mm[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(mm[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
    
    def get_BCiB(self, bcifile, targetfile):
        print ('BCiB..')

        bci = np.zeros((self.bnum, self.cinum))
        with open(bcifile) as infile:
            for line in infile.readlines():
                m, d, _ = line.strip().split('\t')
                bci[int(m)][int(d)] = 1

        mm = bci.dot(bci.T)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(mm.shape[0])[1:]:
                for j in range(mm.shape[1])[1:]:
                    if mm[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(mm[i][j])) + '\n')
                        total += 1
        print ('total = ', total)

    def get_BCaB(self, bcafile, targetfile):
        print ('BCaB..')

        bca = np.zeros((self.bnum, self.canum))
        with open(bcafile) as infile:
            for line in infile.readlines():
                m, a,__ = line.strip().split('\t')
                bca[int(m)][int(a)] = 1

        mm = bca.dot(bca.T)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(mm.shape[0])[1:]:
                for j in range(mm.shape[1])[1:]:
                    if mm[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(mm[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
    
    def get_MTM(self, mtfile, targetfile):
        print ('MTM..')

        mt = np.zeros((self.mnum, self.tnum))
        with open(mtfile) as infile:
            for line in infile.readlines():
                m, a,__ = line.strip().split('\t')
                mt[int(m)][int(a)] = 1

        mm = mt.dot(mt.T)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(mm.shape[0])[1:]:
                for j in range(mm.shape[1])[1:]:
                    if mm[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(mm[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
    
    def get_UBCaBU(self, ub, bcafile, targetfile):
        print ('UBCaBU...')

        bca = np.zeros((self.bnum, self.canum))
        with open(bcafile, 'r') as infile:
            for line in infile.readlines():
                m, d, _ = line.strip().split('\t')
                bca[int(m)][int(d)] = 1

        uu = ub.dot(bca).dot(bca.T).dot(ub.T)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(uu.shape[0]):
                for j in range(uu.shape[1]):
                    if uu[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(uu[i][j])) + '\n')
                        total += 1
        print ('total = ', total)
    
    def get_UBCiBU(self, ub, bcifile, targetfile):
        print ('UBCiBU...')

        bci = np.zeros((self.bnum, self.cinum))
        with open(bcifile, 'r') as infile:
            for line in infile.readlines():
                m, a, _ = line.strip().split('\t')
                bci[int(m)][int(a)] = 1

        uu = ub.dot(bci).dot(bci.T).dot(ub.T)
        print ('writing to file...')
        total = 0
        with open(targetfile, 'w') as outfile:
            for i in range(uu.shape[0]):
                for j in range(uu.shape[1]):
                    if uu[i][j] != 0 and i != j:
                        outfile.write(str(i) + '\t' + str(j) + '\t' + str(int(uu[i][j])) + '\n')
                        total += 1
        print ('total = ', total)


metapathGeneration(unum=MAX_USERS, bnum=MAX_ITEMS, conum=11, canum=511, cinum=47)

"""# Treinando as Embeddings da HIN (Heterogeneous Information Network)"""

import os

train_rate = 0.8
dim = 128
walk_len = 5
win_size = 3
num_walk = 10

metapaths = ['ubu', 'ubcabu', 'ubcibu', 'bub', 'bcab', 'bcib']

for metapath in metapaths:
	metapath = metapath + '_' + str(train_rate)
	input_file = 'data/metapath/' + metapath + '.txt'
	output_file = 'data/embeddings/' + metapath + '.embedding'

	cmd = 'deepwalk --format edgelist --input ' + input_file + ' --output ' + output_file + \
	      ' --walk-length ' + str(walk_len) + ' --window-size ' + str(win_size) + ' --number-walks '\
	       + str(num_walk) + ' --representation-size ' + str(dim)

	print (cmd);
	os.system(cmd)

"""# Treinando o Modelo (Fatoração de Matriz com Embeddings)"""

import numpy as np
import time
import random
from math import sqrt,fabs,log,exp
import sys

class HNERec:
    def __init__(self, unum, inum, ratedim, userdim, itemdim, user_metapaths,item_metapaths, trainfile, testfile, steps, delta, beta_e, beta_h, beta_p, beta_w, beta_b, reg_u, reg_v):
        self.unum = unum
        self.inum = inum
        self.ratedim = ratedim
        self.userdim = userdim
        self.itemdim = itemdim
        self.steps = steps
        self.delta = delta
        self.beta_e = beta_e
        self.beta_h = beta_h
        self.beta_p = beta_p
        self.beta_w = beta_w
        self.beta_b = beta_b
        self.reg_u = reg_u
        self.reg_v = reg_v

        self.user_metapathnum = len(user_metapaths)
        print('User metapathnum=',self.user_metapathnum)

        self.item_metapathnum = len(item_metapaths)
        print('Item metapathnum=',self.item_metapathnum)

        self.X, self.user_metapathdims = self.load_embedding(user_metapaths, unum)
        print ('Load user embeddings finished.')

        self.Y, self.item_metapathdims = self.load_embedding(item_metapaths, inum)
        print ('Load user embeddings finished.')

        self.R, self.T, self.ba = self.load_rating(trainfile, testfile)
        print ('Load rating finished.')
        print ('train size : ', len(self.R))
        print ('test size : ', len(self.T) )

        self.initialize();
        self.recommend();

    def load_embedding(self, metapaths, num):
        X = {}
        for i in range(num):
            X[i] = {}
        metapathdims = []
    
        ctn = 0
        for metapath in metapaths:
            sourcefile = 'data/embeddings/' + metapath
            #print sourcefile
            with open(sourcefile) as infile:
                
                k = int(infile.readline().strip().split(' ')[1])
                metapathdims.append(k)
                for i in range(num):
                    X[i][ctn] = np.zeros(k)

                n = 0
                for line in infile.readlines():
                    n += 1
                    arr = line.strip().split(' ')
                    i = int(arr[0]) - 1
                    for j in range(k):
                        X[i][ctn][j] = float(arr[j + 1])
                print ('metapath ', metapath, 'numbers ', n)
            ctn += 1
        return X, metapathdims

    def load_rating(self, trainfile, testfile):
        R_train = []
        R_test = []
        ba = 0.0
        n = 0
        user_test_dict = dict()
        with open(trainfile) as infile:
            for line in infile.readlines():
                user, item, rating = line.strip().split('\t')
                R_train.append([int(user)-1, int(item)-1, int(rating)])
                ba += int(rating)
                n += 1
        ba = ba / n
        ba = 0
        with open(testfile) as infile:
            for line in infile.readlines():
                user, item, rating = line.strip().split('\t')
                R_test.append([int(user)-1, int(item)-1, int(rating)])

        return R_train, R_test, ba

    def initialize(self):
        self.E = np.random.randn(self.unum, self.itemdim) * 0.1
        self.H = np.random.randn(self.inum, self.userdim) * 0.1
        self.U = np.random.randn(self.unum, self.ratedim) * 0.1
        self.V = np.random.randn(self.inum, self.ratedim) * 0.1

        self.pu = np.ones((self.unum, self.user_metapathnum)) * 1.0 / self.user_metapathnum
        self.pv = np.ones((self.inum, self.item_metapathnum)) * 1.0 / self.item_metapathnum


        self.Wu = {}
        self.bu = {}
        for k in range(self.user_metapathnum):
            self.Wu[k] = np.random.randn(self.userdim, self.user_metapathdims[k]) * 0.1
            self.bu[k] = np.random.randn(self.userdim) * 0.1

        self.Wv = {}
        self.bv = {}
        for k in range(self.item_metapathnum):
            self.Wv[k] = np.random.randn(self.itemdim, self.item_metapathdims[k]) * 0.1
            self.bv[k] = np.random.randn(self.itemdim) * 0.1

    def sigmod(self, x):
        return 1 / (1 + np.exp(-x))

    def cal_u(self, i):
        ui = np.zeros(self.userdim)
        for k in range(self.user_metapathnum):
            ui += self.pu[i][k] * self.sigmod((self.Wu[k].dot(self.X[i][k]) + self.bu[k]))
        return self.sigmod(ui)

    def cal_v(self, j):
        vj = np.zeros(self.itemdim)
        for k in range(self.item_metapathnum):
            vj += self.pv[j][k] * self.sigmod((self.Wv[k].dot(self.Y[j][k]) + self.bv[k]))
        return self.sigmod(vj)

    def get_rating(self, i, j):
        ui = self.cal_u(i)
        vj = self.cal_v(j)
        return self.U[i, :].dot(self.V[j, :]) + self.reg_u * ui.dot(self.H[j, :]) + self.reg_v * self.E[i, :].dot(vj)

    def maermse(self):
        m = 0.0
        mae = 0.0
        rmse = 0.0
        n = 0
        for t in self.T:
            n += 1
            i = t[0]
            j = t[1]
            r = t[2]
            r_p = self.get_rating(i, j)

            if r_p > 5: r_p = 5
            if r_p < 1: r_p = 1
            m = fabs(r_p - r)
            mae += m
            rmse += m * m
        mae = mae * 1.0 / n
        rmse = sqrt(rmse * 1.0 / n)
        return mae, rmse

    def recommend(self):
        mae = []
        rmse = []
        starttime = time.clock()
        perror = 99999
        cerror = 9999
        n = len(self.R)

        for step in range(steps):
            total_error = 0.0
            for t in self.R:
                i = t[0]
                j = t[1]
                rij = t[2]

                rij_t = self.get_rating(i, j)
                eij = rij - rij_t
                total_error += eij * eij
                
                U_g = -eij * self.V[j, :] + self.beta_e * self.U[i, :]
                V_g = -eij * self.U[i, :] + self.beta_h * self.V[j, :]

                self.U[i, :] -= self.delta * U_g
                self.V[j, :] -= self.delta * V_g

                ui = self.cal_u(i)
                for k in range(self.user_metapathnum):
                    x_t = self.sigmod(self.Wu[k].dot(self.X[i][k]) + self.bu[k])
                    
                    pu_g = self.reg_u * -eij * (ui * (1-ui) * self.H[j, :]).dot(x_t) + self.beta_p * self.pu[i][k]
                    
                    Wu_g = self.reg_u * -eij * self.pu[i][k] * np.array([ui * (1-ui) * x_t * (1-x_t) * self.H[j, :]]).T.dot(np.array([self.X[i][k]])) + self.beta_w * self.Wu[k]
                    bu_g = self.reg_u * -eij * ui * (1-ui) * self.pu[i][k] * self.H[j, :] * x_t * (1-x_t) + self.beta_b * self.bu[k]
                    #print pu_g
                    self.pu[i][k] -= 0.1 * self.delta * pu_g
                    self.Wu[k] -= 0.1 * self.delta * Wu_g
                    self.bu[k] -= 0.1 * self.delta * bu_g

                H_g = self.reg_u * -eij * ui + self.beta_h * self.H[j, :]
                self.H[j, :] -= self.delta * H_g

                vj = self.cal_v(j)
                for k in range(self.item_metapathnum):
                    y_t = self.sigmod(self.Wv[k].dot(self.Y[j][k]) + self.bv[k])
                    pv_g = self.reg_v * -eij * (vj * (1-vj) * self.E[i, :]).dot(y_t) + self.beta_p * self.pv[j][k]
                    Wv_g = self.reg_v * -eij  * self.pv[j][k] * np.array([vj * (1-vj) * y_t * (1 - y_t) * self.E[i, :]]).T.dot(np.array([self.Y[j][k]])) + self.beta_w * self.Wv[k]
                    bv_g = self.reg_v * -eij * vj * (1-vj) * self.pv[j][k] * self.E[i, :] * y_t * (1 - y_t) + self.beta_b * self.bv[k]

                    self.pv[j][k] -= 0.1 * self.delta * pv_g
                    self.Wv[k] -= 0.1 * self.delta * Wv_g
                    self.bv[k] -= 0.1 * self.delta * bv_g

                E_g = self.reg_v * -eij * vj + 0.01 * self.E[i, :]
                self.E[i, :] -= self.delta * E_g

            perror = cerror
            cerror = total_error / n
            
            self.delta = 0.93 * self.delta

            if(abs(perror - cerror) < 0.0001):
                break
            print ('step ', step, 'crror : ', sqrt(cerror))
            MAE, RMSE = self.maermse()
            mae.append(MAE)
            rmse.append(RMSE)
            print ('MAE, RMSE ', MAE, RMSE)
            endtime = time.clock()
            #print 'time: ', endtime - starttime
        print ('MAE: ', min(mae), ' RMSE: ', min(rmse))


unum = MAX_USERS
inum = MAX_ITEMS
ratedim = 10
userdim = 30
itemdim = 10
train_rate = 0.8#sys.argv[1]

user_metapaths = ['ubu', 'ubcibu', 'ubcabu']
item_metapaths = ['bub', 'bcib', 'bcab']

for i in range(len(user_metapaths)):
  user_metapaths[i] += '_' + str(train_rate) + '.embedding'
for i in range(len(item_metapaths)):
  item_metapaths[i] += '_' + str(train_rate) + '.embedding'


trainfile = 'data/ub_'+str(train_rate)+'.train'
testfile = 'data/ub_'+str(train_rate)+'.test'
steps = 100
delta = 0.02
beta_e = 0.1
beta_h = 0.1
beta_p = 2
beta_w = 0.1
beta_b = 0.1
reg_u = 1.0
reg_v = 1.0
print ('train_rate: ', train_rate)
print ('ratedim: ', ratedim, ' userdim: ', userdim, ' itemdim: ', itemdim)
print ('max_steps: ', steps)
print ('delta: ', delta, 'beta_e: ', beta_e, 'beta_h: ', beta_h, 'beta_p: ', beta_p, 'beta_w: ', beta_w, 'beta_b', beta_b, 'reg_u', reg_u, 'reg_v', reg_v)

HNERec(unum, inum, ratedim, userdim, itemdim, user_metapaths, item_metapaths, trainfile, testfile, steps, delta, beta_e, beta_h, beta_p, beta_w, beta_b, reg_u, reg_v)

"""# Vamos comparar contra um baseline (Neural Colaborative Filtering)
* HE, Xiangnan et al. Neural collaborative filtering. In: Proceedings of the 26th international conference on world wide web. 2017. p. 173-182.
* Implementação baseada em: https://keras.io/examples/structured_data/collaborative_filtering_movielens/

## Carregando treino e teste
"""

df_train = pd.read_csv('data/ub_0.8.train',sep="\t",header=None)
df_test = pd.read_csv('data/ub_0.8.test',sep="\t",header=None)


x_train = df_train[[0,1]].values
y_train = df_train[2].values

x_val = df_test[[0,1]].values
y_val = df_test[2].values

x_train

y_train

"""## Modelo (RecommenderNet)"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

EMBEDDING_SIZE = 128

class RecommenderNet(keras.Model):
    def __init__(self, num_users, num_items, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.num_users = num_users
        self.num_items = num_items
        self.embedding_size = embedding_size
        self.user_embedding = layers.Embedding(
            num_users,
            embedding_size,
            embeddings_initializer="he_normal",
            embeddings_regularizer=keras.regularizers.l2(1e-6),
        )
        self.user_bias = layers.Embedding(num_users, 1)
        self.item_embedding = layers.Embedding(
            num_items,
            embedding_size,
            embeddings_initializer="he_normal",
            embeddings_regularizer=keras.regularizers.l2(1e-6),
        )
        self.item_bias = layers.Embedding(num_items, 1)

    def call(self, inputs):
        user_vector = self.user_embedding(inputs[:, 0])
        user_bias = self.user_bias(inputs[:, 0])
        item_vector = self.item_embedding(inputs[:, 1])
        item_bias = self.item_bias(inputs[:, 1])
        dot_user_item = tf.tensordot(user_vector, item_vector, 2)
        # Add all the components (including bias)
        x = dot_user_item + user_bias + item_bias
        # The sigmoid activation forces the rating to between 0 and 1
        return tf.nn.sigmoid(x)


model = RecommenderNet(MAX_USERS, MAX_ITEMS, EMBEDDING_SIZE)
model.compile(
    loss='mse', optimizer=keras.optimizers.Adam(lr=0.001), metrics=['mae',tf.keras.metrics.RootMeanSquaredError()]
)

"""## Treinando / Avaliando"""

history = model.fit(
    x=x_train,
    y=y_train,
    batch_size=64,
    epochs=70,
    verbose=1,
    validation_data=(x_val, y_val),
)

